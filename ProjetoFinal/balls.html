<!DOCTYPE html>
<html>
    <head>
        <title>My Three.js Game</title>
        <link rel="stylesheet" type="text/css" href="style.css">
        <style>
          body {
            margin: 0;
            overflow: hidden;
          }
          canvas {
            display: block;
          }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
      </head>
<body>
    <div id="menu" style="position: absolute; top: 0; right: 0; padding: 10px; background-color: rgba(255, 255, 255, 0.5);">
		<h3>Menu</h3>
		<button onclick="addBall()">Add Ball</button>
		<button onclick="removeBall()">Remove Ball</button>
		<button onclick="addSpotlight()">Add Spotlight</button>
		<button onclick="removeSpotlight()">Remove Spotlight</button>
	</div>
	<script>
        // Set up the scene, camera, and renderer
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 20; // move the camera back
        camera.fov = 50; // increase the field of view
        camera.updateProjectionMatrix(); // update the camera projection matrix

        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create a box with a wireframe material
        var boxGeometry = new THREE.BoxGeometry(10, 10, 10);
        var boxMaterial = new THREE.MeshBasicMaterial({ wireframe: true, transparent: true, opacity: 0.5 });
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        scene.add(box);

        // Create an array of bouncy balls
        var balls = [];
        for (var i = 0; i < 10; i++) {
        var ballGeometry = new THREE.SphereGeometry(1, 32, 32);
        var ballMaterial = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
        var ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.set(
            Math.random() * 8 - 4,
            Math.random() * 8 - 4,
            Math.random() * 8 - 4
        );
        ball.velocity = new THREE.Vector3(
            Math.random() * 0.1 - 0.05,
            Math.random() * 0.1 - 0.05,
            Math.random() * 0.1 - 0.05
        );
        balls.push(ball);
        scene.add(ball);
        }
        
        // Create a spotlight
        var spotlight = new THREE.SpotLight(0xffffff, 1, 100);
        spotlight.position.set(0, 10, 0);
        scene.add(spotlight);

        // Set up the bounding box for the box
        var boxBox = new THREE.Box3().setFromObject(box);

        // Add a spotlight to a random ball
        function addSpotlight() {
        if (spotlight) {
            removeSpotlight();
        }
        var ball = balls[Math.floor(Math.random() * balls.length)];
        spotlight = new THREE.SpotLight(0xffffff, 1);
        spotlight.position.copy(ball.position);
        spotlight.target.position.copy(ball.position);
        scene.add(spotlight);
        scene.add(spotlight.target);
        }

        // Remove the spotlight from the ball that was previously highlighted
        function removeSpotlight() {
        if (spotlight) {
            scene.remove(spotlight);
            scene.remove(spotlight.target);
            spotlight = null;
        }
        }

        // Add a ball to the scene
        function addBall() {
        if (balls.length < 10) {
            var ballGeometry = new THREE.SphereGeometry(1, 32, 32);
            var ballMaterial = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
            var ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(
            Math.random() * 8 - 4,
            Math.random() * 8 - 4,
            Math.random() * 8 - 4
            );
            ball.velocity = new THREE.Vector3(
            Math.random() * 0.1 - 0.05,
            Math.random() * 0.1 - 0.05,
            Math.random() * 0.1 - 0.05
            );
            balls.push(ball);
            scene.add(ball);
        }
        }

        // Remove a ball from the scene
        function removeBall() {
        if (balls.length > 1) {
            var ball = balls.pop();
            scene.remove(ball);
        }
        }
        // Render the scene
        function render() {
        requestAnimationFrame(render);
        
        // Update the positions of the balls
        for (var i = 0; i < balls.length; i++) {
            var ball = balls[i];
            
            // Update the velocity and position of the ball
            ball.velocity.y -= 0.01;
            ball.position.add(ball.velocity);
            
            // Check for collisions between the ball and the box
            var ballBox = new THREE.Box3().setFromObject(ball);
            if (!boxBox.containsBox(ballBox)) {
            if (ballBox.min.x < boxBox.min.x || ballBox.max.x > boxBox.max.x) {
                ball.velocity.x = -ball.velocity.x;
            }
            if (ballBox.min.y < boxBox.min.y || ballBox.max.y > boxBox.max.y) {
                ball.velocity.y = -ball.velocity.y;
            }
            if (ballBox.min.z < boxBox.min.z || ballBox.max.z > boxBox.max.z) {
                ball.velocity.z = -ball.velocity.z;
            }
            ball.position.clamp(boxBox.min, boxBox.max);
            }
        }

        renderer.render(scene, camera);
        
        if (isDragging) {
            var deltaX = mouseCoords.x - lastMouseCoords.x;
            var deltaY = mouseCoords.y - lastMouseCoords.y;

            rotateScene(deltaX, deltaY);
        }

        balls.forEach(function (ball, index) {
            var x = ball.position.x;
            var y = ball.position.y;
            var z = ball.position.z;
            var vector = new THREE.Vector3(x, y, z);
            vector.applyAxisAngle(axis, radians);
            ball.position.set(vector.x, vector.y, vector.z);
        });

        lastMouseCoords.x = mouseCoords.x;
        lastMouseCoords.y = mouseCoords.y;

        // Clear the canvas
        context.clearRect(0, 0, canvas.width, canvas.height);

        // Calculate the camera position
        let cameraX = 0;
        let cameraY = 0;
        let cameraZ = -(boxSize + cameraDistance);
        let rotX = rotateX;
        let rotY = rotateY;

        // Apply zoom
        cameraZ *= zoomFactor;

        // Apply rotation
        let rotationMatrix = mat4.create();
        mat4.rotateX(rotationMatrix, rotationMatrix, rotX);
        mat4.rotateY(rotationMatrix, rotationMatrix, rotY);
        vec3.transformMat4([cameraX, cameraY, cameraZ], [cameraX, cameraY, cameraZ], rotationMatrix);

        // Set up the view matrix
        let viewMatrix = mat4.create();
        mat4.lookAt(viewMatrix, [cameraX, cameraY, cameraZ], [0, 0, 0], [0, 1, 0]);

        // Draw the box
        drawBox(viewMatrix);

        // Draw the balls
        for (let i = 0; i < balls.length; i++) {
        let ball = balls[i];
        let modelMatrix = mat4.create();
        mat4.translate(modelMatrix, modelMatrix, ball.position);
        drawBall(viewMatrix, modelMatrix, ball.radius, ball.color, ball.isSpotlit);
        }

        // Schedule the next frame
        requestAnimationFrame(render);
        }

        // Mouse controls
        var isDragging = false;
        var previousMousePosition = {
        x: 0,
        y: 0
        };

        function animate() {
        requestAnimationFrame(animate);

        // Rotate the box
        controls.update();
        box.rotation.x = controls.getAzimuthalAngle();
        box.rotation.y = controls.getPolarAngle();

        // Rotate the balls
        for (let i = 0; i < balls.length; i++) {
            const ball = balls[i];
            const { x, y, z } = ball.userData.originalPosition;
            const newPosition = new THREE.Vector3(x, y, z).applyQuaternion(box.quaternion);
            ball.position.set(newPosition.x, newPosition.y, newPosition.z);
            ball.rotation.setFromQuaternion(box.quaternion);
        }

        renderer.render(scene, camera);
        }

        function onMouseMove(event) {
        if (isDragging) {
            // rotation around the x-axis
            box.rotation.x += (event.clientY - previousMousePosition.y) * 0.01;

            // rotation around the y-axis
            box.rotation.y += (event.clientX - previousMousePosition.x) * 0.01;
        }
        previousMousePosition = {
            x: event.clientX,
            y: event.clientY
        };
        }

        function onMouseDown(event) {
        isDragging = true;
        }

        function onMouseUp(event) {
        isDragging = false;
        }

        function onMouseWheel(event) {
        camera.position.z += event.deltaY * 0.1;
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mouseup', onMouseUp);
        document.addEventListener('wheel', onMouseWheel);

        // ZOOMING FEATURE
        let zoom = 1;

        function handleScroll(event) {
        zoom += event.deltaY * -0.001;
        zoom = Math.min(Math.max(0.1, zoom), 10);
        camera.position.z = 50 / zoom;
        }

        window.addEventListener("wheel", handleScroll);

        render();

    </script>
</body>
</html>