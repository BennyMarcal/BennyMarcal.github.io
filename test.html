<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Three.js GUI Example</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script>
        // Create the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Create an array to store the cubes
        const cubes = [];

        // Add ambient and directional lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        scene.add(directionalLight);

        // Enable shadows
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // GUI parameters
        const guiParams = {
            rotationSpeed: 0.02,
            scale: 1,
            color: "#00ff00",
            ambientLight: true,
            directionalLight: true,
            addCube: addCube,
            changeShape: changeShape,
            dayNightCycle: true,
            partyMode: false
        };

        // Create the dat.GUI instance
        const gui = new dat.GUI();

        // Add controls to the GUI
        const rotationController = gui.add(guiParams, 'rotationSpeed', -0.1, 0.1).name('Rotation Speed');
        const scaleController = gui.add(guiParams, 'scale', 0.1, 2).name('Scale');
        const colorController = gui.addColor(guiParams, 'color').name('Color').onChange(updateColor);
        gui.add(guiParams, 'ambientLight').name('Ambient Light').onChange(updateLighting);
        gui.add(guiParams, 'directionalLight').name('Directional Light').onChange(updateLighting);
        gui.add(guiParams, 'addCube').name('Add Cube');
        gui.add(guiParams, 'changeShape').name('Change Shape');
        gui.add(guiParams, 'dayNightCycle').name('Day/Night Cycle');
        gui.add(guiParams, 'partyMode').name('Party Mode');

        // Function to update the cube's color based on the GUI parameter
        function updateColor() {
            cubes.forEach(cube => {
                cube.material.color.set(guiParams.color);
            });
        }

        // Function to update the lighting in the scene based on the GUI parameters
        function updateLighting() {
            ambientLight.visible = guiParams.ambientLight;
            directionalLight.visible = guiParams.directionalLight;
        }

        // Function to add a new cube to the scene
        function addCube() {
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshPhongMaterial({ color: guiParams.color });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(Math.random() * 10 - 5, Math.random() * 10 - 5, Math.random() * 10 - 5);
            cube.castShadow = true;
            scene.add(cube);
            cubes.push(cube);
            updateColor();
        }

        // Function to change the shape of the cubes to another geometric shape
        function changeShape() {
            const shapeTypes = ['Box', 'Sphere', 'Cone'];
            const randomShape = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];

            cubes.forEach(cube => {
                let geometry;
                if (randomShape === 'Sphere') {
                    geometry = new THREE.SphereGeometry();
                } else if (randomShape === 'Cone') {
                    geometry = new THREE.ConeGeometry();
                } else {
                    geometry = new THREE.BoxGeometry();
                }
                cube.geometry.dispose();
                cube.geometry = geometry;
            });
        }

        // Function to update the cube's position and rotation
        function updateCube() {
            cubes.forEach(cube => {
                cube.rotation.x += guiParams.rotationSpeed;
                cube.rotation.y += guiParams.rotationSpeed;
                cube.scale.set(guiParams.scale, guiParams.scale, guiParams.scale);
            });
        }

        // Create the sun and moon
        const sunGeometry = new THREE.CircleGeometry(1, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(0, 0, 0);
        scene.add(sun);

        const moonGeometry = new THREE.CircleGeometry(1, 32);
        const moonMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(0, 0, 0);
        scene.add(moon);

        // Function to update the day/night cycle
        function updateDayNightCycle() {
            if (guiParams.dayNightCycle) {
                const time = performance.now() * 0.0004; // Increase the value to make the cycle faster

                // Rotate directional light
                directionalLight.position.x = Math.sin(time * 0.7) * 10;
                directionalLight.position.y = Math.cos(time * 0.5) * 10;
                directionalLight.position.z = Math.cos(time * 0.3) * 10;

                // Set background color based on the position of the sun
                const lightIntensity = (directionalLight.position.y + 5) / 10;
                const blueColor = new THREE.Color().setHSL(0.6, 0.6, 0.9);
                const blackColor = new THREE.Color(0x89cff0);
                const backgroundColor = new THREE.Color().lerp(blackColor, blueColor, lightIntensity);
                renderer.setClearColor(backgroundColor);

                // Set sun and moon visibility based on the y position of the directional light
                sun.visible = directionalLight.position.y >= 0;
                moon.visible = directionalLight.position.y < 0;

                // Set sun and moon position
                sun.position.copy(directionalLight.position);
                moon.position.copy(directionalLight.position);

                // Set sun and moon scale
                const scale = Math.abs(directionalLight.position.y) / 10;
                sun.scale.set(scale, scale, 1);
                moon.scale.set(scale, scale, 1);

                // Set sunlight color and intensity
                const sunlightColor = new THREE.Color().setHSL(0.1, 1, lightIntensity * 0.7);
                directionalLight.color.copy(sunlightColor);
            } else {
                // Reset directional light position
                directionalLight.position.set(0, 1, 0);

                // Reset background color to black
                renderer.setClearColor(0x89cff0);

                // Hide sun and moon
                sun.visible = false;
                moon.visible = false;
            }
        }

        // Function to update the party mode
        function updatePartyMode() {
            if (guiParams.partyMode) {
                const shapes = ['Box', 'Sphere', 'Cone'];

                setInterval(() => {
                    cubes.forEach(cube => {
                        const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
                        const randomColor = Math.random() * 0xffffff;

                        let geometry;
                        if (randomShape === 'Sphere') {
                            geometry = new THREE.SphereGeometry();
                        } else if (randomShape === 'Cone') {
                            geometry = new THREE.ConeGeometry();
                        } else {
                            geometry = new THREE.BoxGeometry();
                        }

                        cube.geometry.dispose();
                        cube.geometry = geometry;
                        cube.material.color.setHex(randomColor);
                    });
                }, 2000);
            } else {
                // Reset shapes and colors
                cubes.forEach(cube => {
                    cube.geometry.dispose();
                    cube.geometry = new THREE.BoxGeometry();
                    cube.material.color.set(guiParams.color);
                });
            }
        }

        // Create the floor
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Set initial cube color and lighting
        updateColor();
        updateLighting();

        // Set initial camera position
        camera.position.z = 10;

        // Add event listener for scroll wheel zoom
        window.addEventListener('wheel', onDocumentMouseWheel, false);

        // Function to handle scroll wheel events
        function onDocumentMouseWheel(event) {
            event.preventDefault();

            // Adjust camera position based on scroll direction
            const zoomSpeed = 0.1;
            if (event.deltaY < 0) {
                camera.position.z /= (1 - zoomSpeed);
            } else {
                camera.position.z *= (1 - zoomSpeed);
            }
        }

        // Render loop
        function animate() {
            requestAnimationFrame(animate);

            // Update cube rotation and scale
            updateCube();

            // Update day/night cycle
            updateDayNightCycle();

            // Update party mode
            updatePartyMode();

            // Render the scene
            renderer.render(scene, camera);
        }

        // Resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Event listeners
        window.addEventListener('resize', onWindowResize, false);

        // Start the animation
        animate();
    </script>
</body>
</html>
