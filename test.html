<!DOCTYPE html>
<html lang="pt">
  <head>
    <meta charset="UTF-8">
    <title>Three.js Character Control</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
          "imports": {
            "three": "https://threejs.org/build/three.module.js"
            "gltf": "https://threejs.org/examples/jsm/loaders/GLTFLoader.js";
            "orbit": "https://threejs.org/examples/jsm/controls/OrbitControls.js";
          }
        }
    </script>

    <script type="module">

      import * as THREE from 'three';
      import { GLTFLoader } from 'gltf';
      import { OrbitControls } from 'orbit';

      // Define the global variables
      let camera, scene, renderer, orbit;
      let character, portals = [];

      // Initialize the three.js environment
      function init() {
        // Create the camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.8, 5);

        // Create the scene
        scene = new THREE.Scene();

        // Create the renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create the OrbitControls instance
        orbit = new OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        orbit.dampingFactor = 0.05;
        orbit.minDistance = 1;
        orbit.maxDistance = 50;
        orbit.maxPolarAngle = Math.PI / 2;

        // Load the character model using the GLTFLoader
        const loader = new GLTFLoader();
        loader.load('character.glb', function(gltf) {
          character = gltf.scene;
          scene.add(character);
        });

        // Create the portals
        for (let i = 0; i < 3; i++) {
          const portal = new THREE.Mesh(
            new THREE.BoxGeometry(1, 2, 1),
            new THREE.MeshBasicMaterial({ color: 0x00ff00 })
          );
          portal.position.set(i * 3 - 3, 1, -10);
          scene.add(portal);
          portals.push(portal);
        }

        // Set up the keyboard controls
        document.addEventListener('keydown', onKeyDown, false);
      }

      // Animate the character and the portals
      function animate() {
        requestAnimationFrame(animate);
        // Update the character position based on the keyboard controls
        checkCollisions();
        renderer.render(scene, camera);
        orbit.update(); // update the state of OrbitControls
      }

      // Handle the keyboard controls
      function onKeyDown(event) {
          if (keyboard['w']) {
          cube.position.z -= 0.1;
          }
          if (keyboard['s']) {
            cube.position.z += 0.1;
          }
          if (keyboard['d']) {
            cube.position.x += 0.1;
          }
          if (keyboard['a']) {
            cube.position.x -= 0.1;
          }
      }

      // Check if the character collides with any portal
      function checkCollisions() {
        for (let i = 0; i < portals.length; i++) {
          if (character.position.distanceTo(portals[i].position) < 1) {
            window.location.href = 'portal' + i + '.html';
          }
        }
      }

      // Initialize and animate the three.js environment
      init();
      animate();
    </script>
  </body>
</html>
